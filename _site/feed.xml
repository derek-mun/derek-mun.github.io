<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://0.0.0.0/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0/" rel="alternate" type="text/html" /><updated>2020-04-22T21:09:00+09:00</updated><id>http://0.0.0.0/feed.xml</id><title type="html">Derek’s blog</title><entry><title type="html">Linux Shell 프로그램 실행시간 구하기</title><link href="http://0.0.0.0/in%20console/2020/04/21/In-Console-Linux_shell_excute_time.html" rel="alternate" type="text/html" title="Linux Shell 프로그램 실행시간 구하기" /><published>2020-04-21T00:00:00+09:00</published><updated>2020-04-21T00:00:00+09:00</updated><id>http://0.0.0.0/in%20console/2020/04/21/In-Console-Linux_shell_excute_time</id><content type="html" xml:base="http://0.0.0.0/in%20console/2020/04/21/In-Console-Linux_shell_excute_time.html">&lt;blockquote&gt;
  &lt;p&gt;내가 작성한 쉘 혹은 기타 어플리케이션의 실행시간을 구하고싶을때 아래 방법으로 구할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;프로그램-실행시간-구하기&quot;&gt;프로그램 실행시간 구하기&lt;/h2&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:/sbin:/bin:/usr/sbin:/usr/bin
&lt;span class=&quot;nv&quot;&gt;StartTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; +%s&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#실행할 커맨드들을 작성&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;EndTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; +%s&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;It takes &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$EndTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$StartTime&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; seconds to complete this task.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Linux" /><category term="Shell" /><category term="Script" /><summary type="html">내가 작성한 쉘 혹은 기타 어플리케이션의 실행시간을 구하고싶을때 아래 방법으로 구할 수 있다.</summary></entry><entry><title type="html">독서: 미래를 바꾼 아홉가지 알고리즘</title><link href="http://0.0.0.0/etc/2020/04/20/Book-Nine-Algorithms-that-changed-the-future.html" rel="alternate" type="text/html" title="독서: 미래를 바꾼 아홉가지 알고리즘" /><published>2020-04-20T00:00:00+09:00</published><updated>2020-04-20T00:00:00+09:00</updated><id>http://0.0.0.0/etc/2020/04/20/Book-Nine-Algorithms-that-changed-the-future</id><content type="html" xml:base="http://0.0.0.0/etc/2020/04/20/Book-Nine-Algorithms-that-changed-the-future.html">&lt;p&gt;우연히 발견한 책이지만, 나름 재밌게 읽어서 정리함.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/post_img/Nine-Algorithms-that-changed-the-future.jpg&quot; alt=&quot;미래를 바꾼 아홉가지 알고리즘&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;-미래를-바꾼-아홉가지-알고리즘-&quot;&gt;&lt;a href=&quot;https://www.yes24.com/24/Goods/8921236?Acode=101&quot;&gt; 미래를 바꾼 아홉가지 알고리즘 &lt;/a&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;첫 챕터만 봐도 컴퓨터 전공자만을 위한 책이 아니라는 것을 알 수 있다. 좋은 책이라고 생각한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;chapter-1---컴퓨터를-움직이는-위대한-아이디어들&quot;&gt;Chapter 1 - [컴퓨터를 움직이는 위대한 아이디어들]&lt;/h3&gt;

&lt;p&gt;컴퓨터과학자들은 자신들의 중요한 아이디어의 상당수를 ‘알고리즘(Algorithm)’ 이라고 표현한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;알고리즘이란
    &lt;ul&gt;
      &lt;li&gt;문제를 푸는 데 필요한 단계의 순서를 명확히 명시하는 구체적인 계산법.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 책을 읽었다고 해서 매우 숙련된 컴퓨터 사용자가 될 수는 없겠지만, 컴퓨터 장치에서 여러분이 매일 끊임없이 이용하는 알고리즘의 아름다움을 훨씬 깊이 느낄 수 있게 될 것이다.
    &lt;ul&gt;
      &lt;li&gt;그게 왜 좋을까? 비유를 들어 보겠다. 나는 천문학 전문가가 아니다. 사실 천문학에 대해 상당히 무지하고 더 많이 알고 싶어 한다. 그러나 내가 가진 매우 짧은 천문학 지식 덕분에 밤 하늘을 볼 때마다 즐거움이 배가된다. 내가 바라보는 대상에 관한 이해가 만족감과 경탄을 낳기 마련이다. 책을 읽은 뒤 컴퓨터를 사용하면서 이런 기쁨을 가끔은 느끼게 되길 진심으로 바란다.우리 시대에서 가장 편재하고 불가해한 블랙박스인 컴퓨터, 즉 여러분 앞에 놓인 천재의 진가를 알아보게 될 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-2---검색엔진-인덱싱-세상에서-가장-큰-건초-더미에서-바늘찾기&quot;&gt;Chapter 2 - [검색엔진 인덱싱: 세상에서 가장 큰 건초 더미에서 바늘찾기]&lt;/h3&gt;

&lt;p&gt;검색엔진은 우리 삶에 엄청난 영향을 미쳤다. 우리 대부분은 하루에도 몇 번씩 검색 쿼리를 던지지만 이 탁월한 툴의 작동 원리를 그다지 궁금해 하지 않는다. 막대한 정보의 양도, 빠른 속도로 나오는 훌륭한 결과도 이제는 늘 있는 일이라, 몇 초 안에 질문에 대한 답을 얻지 못하면 짜증이 밀려온다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;매칭과 랭킹&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;가장 좋은 소수의 검색결과를 적절한 순서로 선별하는 작업을 ‘랭킹’이라 부른다. 랭킹은 매칭이라는 첫 단계를 뒤따르는 중요한 두 번째 단계이다. 검색 산업이라는 치열한 경쟁 세계에서 검색엔진은 랭킹 시스템의 질에 따라 살거나 죽는다.&lt;/li&gt;
      &lt;li&gt;2002년 미국 최고 검색엔진 시장은 구글,야후, MSN이 각각 30% 가량을 점유했다. (MSN -&amp;gt; Live Search -&amp;gt; Bing) 이후 몇 년간 구글이 시장 점유율에서 극적으로 성장하며 야후와 MSN을 각각 20%이하로 떨어뜨렸다.&lt;/li&gt;
      &lt;li&gt;구글이 검색 산업의 강자로 부상하게 된 것은 랭킹 알고리즘 덕분이라 여겨진다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;검색엔진은 랭킹 알고리즘의 질에 따라 살거나 죽는다&lt;/strong&gt;는 말은 절대 과장이 아니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;알타 비스타 : 최초의 웹 규모 매칭 알고리즘&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;검색엔진 매칭 알고리즘에 대해 많은 사람들이 21세기 초에 일어난 위대한 기술 성공 신화인 구글이 태오라고 생각할 것이다.&lt;/li&gt;
      &lt;li&gt;웹 검색이라는 발상은 수년 전부터 이미 존재했다. 웹 검색기법을 최초로 상용 도입한 기업은 인포시크와 라이코스, 그리고 1955년에 검색엔진을 출범시킨 &lt;a href=&quot;https://namu.wiki/w/%EC%95%8C%ED%83%80%EB%B9%84%EC%8A%A4%ED%83%80&quot;&gt;알타비스타(AltaVista)&lt;/a&gt;였다.&lt;/li&gt;
      &lt;li&gt;1990년대 중반 몇 년 동안 알타비스타는 검색엔진의 왕이었다.&lt;/li&gt;
      &lt;li&gt;최초로 검색엔진은 웹의 모든 페이지에 있는 모든 텍스트를 완전히 인덱싱했다. (눈 깜빡할 사이에 결과가 떴다.)&lt;/li&gt;
      &lt;li&gt;이 획기적 기술발전을 이해하려면 아주 오래된 개념인 인덱싱부터 살펴 봐야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오래된 평범한 인덱싱&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;인덱스(index)란 개념은 모든 검색엔진 이면에 있는 가장 근본적 발상이다.&lt;/li&gt;
      &lt;li&gt;웹 검색엔진용 인덱스는 책의 인덱스와 같은 방식으로 작동한다.&lt;/li&gt;
      &lt;li&gt;구문 쿼리(phrase query)처리 문제 때문에 단순한 인덱싱으로는 부족하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단어 위치 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;구문 쿼리 문제의 해결책이 오늘날 검색엔진을 잘 작동하게 만든 첫 번째 기발한 발상이다.&lt;/li&gt;
      &lt;li&gt;인덱스가 페이지 번호뿐 아니라 페이지 안의 위치도 저장해야 한다는 아이디어에서 출발한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;랭킹과 근접성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용자에 보여 줄 소수의 상위 검색결과를 설변하는 단계가 ‘랭킹’이다.&lt;/li&gt;
      &lt;li&gt;페이지의 ‘순위’는 실제로 무엇에 달려 있는가?
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;‘이 페이지가 쿼리에 부합하는가?’&lt;/strong&gt;가 아니라 &lt;strong&gt;‘이 페이지가 쿼리에 적합한가?’&lt;/strong&gt; 이다.&lt;/li&gt;
          &lt;li&gt;컴퓨터과학자는 ‘적합성’ 이란 용어를 주어진 페이지가 특정 쿼리에 적압하거나 유용한 정도를 기술하는 데 쓴다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메타워드 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;대부분 웹페이지는 제목, 표제, 링크, 이미지 등 구조가 꽤 복잡하다.&lt;/li&gt;
      &lt;li&gt;메타워드 : 제목의 시작, 끝, 표제의 시작, 끝 등을 말함.&lt;/li&gt;
      &lt;li&gt;보통 단어와 같은 방식으로 메타워드를 인덱싱하는 트릭을 &lt;strong&gt;메타워드 트릭&lt;/strong&gt; 이라고 한다. 터무니 없이 간단해 보일 수도 있지만 메타워드 트릭은 검색엔진이 정확한 결과와 고품질의 랭킹을 내는 데 결정적인 역할을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인덱싱과 매칭 트릭이 전부는 아니다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이 장에서 소개한 두 트릭만으로 효과적 검색엔진 인덱스를 구축하지는 못한다는 사실을 반드시 인식해야 한다. 그러나 단어 위치 트릭과 메타워드 트릭은 분명히 실제 검색엔진이 인덱스를 구축하고 이용하는 방식을 맛배기로 보여준다.&lt;/li&gt;
      &lt;li&gt;알타비스타가 (다른 검색엔진은 실패했던) 전체 웹에서 딱 들어맛는 결과를 찾는 데 성공한 이유는 메타워드 트릭 덕분이었다는 것을 1999년 알타비스타가 제출한 **&amp;lt;인덱스 제한 검색(Constrained Searching of and Index)&amp;gt; 라는 미국 특허를 통해 볼수 있다.&lt;/li&gt;
      &lt;li&gt;우리가 이미 알고 있듯 효율적 매칭은 효과적 검색엔진이 되는 데 딱 절반 정도의 역할을 할 뿐이다. 나머지 과제는 적절하게 매칭된 페이지의 순위를 매기는 일, 즉 &lt;strong&gt;랭킹&lt;/strong&gt;이다. 다음 장에서 보겠지만 새로운 유형의 랭킹 알고리즘은 알타비스타를 몰락시키고 구글을 웹 검색 세계의 중심으로 올려 놓기에 충분했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-3---페이지-랭크-구글을-출범시킨-기술&quot;&gt;Chapter 3 - [페이지 랭크: 구글을 출범시킨 기술]&lt;/h3&gt;

&lt;p&gt;구글이 검색결과의 순위를 매기는 데 이용한 혁신적 알고리즘은 &lt;strong&gt;페이지랭크&lt;/strong&gt; 이다. 이는 웹페이지 순위를 매기는 알고리즘인 동시에 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%9E%98%EB%A6%AC_%ED%8E%98%EC%9D%B4%EC%A7%80&quot;&gt;래리 페이지&lt;/a&gt;가 개발한 랭킹 알고리즘이기도 하다.
이 장에서는 검색 쿼리에 가장 적합한 결과를 상위 검색결과로 산출할 수 있는 방법과 요인을 살펴본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;하이퍼링크 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%95%98%EC%9D%B4%ED%8D%BC%EB%A7%81%ED%81%AC&quot;&gt;하이퍼링크&lt;/a&gt;란 클릭했을 때 다른 웹페이지로 연결하는 웹페이지 구문이다. 대부분 웹브라우저에서는 눈에 쉽게 띄도록 파란색 밑줄이 표시되어 있다.&lt;/li&gt;
      &lt;li&gt;페이지 랭크를 이해하는 첫 단계는 이 책에서 하이퍼링크 트릭 이라고 부를 간단한 발상이다.&lt;/li&gt;
      &lt;li&gt;각 페이지에서 연결된 페이지 수를 세어 각 페이지에 있는 인커밍링크 (incoming link) 의 수에 따라 순위를 매기는 방법으로 접근했다. 물론 사람이 페이지 전체를 읽고 순위를 수동으로 결정하는 방법만큼 정확하지 않지만 유용한 기법이다.&lt;/li&gt;
      &lt;li&gt;한 가지 명백한 점은 때론 링크가 좋은 페이지가 아닌 나쁜 페이지를 지칭하는 데 이용된다는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;권위 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;페이지의 모든 인커밍 링크를 동등하게 취급하는 것은 좋은 방법이 아니다.&lt;/li&gt;
      &lt;li&gt;전문가의 추천은 일반인의 추천보다 분명히 더 가치가 있다로 출발한 아이디어.&lt;/li&gt;
      &lt;li&gt;사이클이 생길 수 있다. (단점)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;무작위 서퍼 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사이퍼링크는 컴퓨터과학자가 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%88%9C%ED%99%98_(%EA%B7%B8%EB%9E%98%ED%94%84_%EC%9D%B4%EB%A1%A0)&quot;&gt;‘사이클’&lt;/a&gt;이라고 부르는 것을 형성할 가능성이 꽤있다.&lt;/li&gt;
      &lt;li&gt;무작위 서퍼 트릭은 하이퍼링크와 권위 트릭의 순기능을 결합했지만 하이퍼링크 사이클이 있을 때도 작동한다.&lt;/li&gt;
      &lt;li&gt;무작위로 인커밍 링크중 하나를 방문하는식으로하여 점수를 메긴다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실제 페이지 링크&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;페이지랭크의 핵심을 공격하는 웹 스팸(web spam) 때문에 많은 연구가 지속됨.&lt;/li&gt;
      &lt;li&gt;상용 검색엔진이 페이지랭크 같은 링크 기반 랭킹 알고리즘 외에도 훨씬 더 많은 것을 이용해 순위를 결정한다.&lt;/li&gt;
      &lt;li&gt;1998년 공개된 구글 설명에서조차 구글의 두 공동 창업자는 검색결과 랭킹을 기여하는 여러 다른 특징을 언급했다.&lt;/li&gt;
      &lt;li&gt;구글의 웹사이트는 페이지 중요도 평가에 200개 이상의 신호를 이용한다고 한다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오늘날 검색엔진이 매우 복잡해지기는 했지만, ‘권위 있는 페이지는 하이퍼링크를 통해 다른 페이지에 권위를 부여한다.’는 페이지랭크의 핵심 아이디어는 여전히 유효한다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-4---공개-키-암호화-공개-엽서에-비밀을-적어-아무도-모르게-보내는-방법&quot;&gt;Chapter 4 - [공개 키 암호화: 공개 엽서에 비밀을 적어 아무도 모르게 보내는 방법]&lt;/h3&gt;

&lt;p&gt;인터넷상의 어떤 메시지든 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%9D%BC%EC%9A%B0%ED%84%B0&quot;&gt;라우터(router)&lt;/a&gt;라 불리는 수많은 컴퓨터를 거쳐 여행하기에 이 라우터에 접속하면 누구든지 메시지 내용을 볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;공유 비밀로 암호화&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;128비트 암호화
        &lt;ul&gt;
          &lt;li&gt;덧셈 트릭을 이용한 암호화 기법&lt;/li&gt;
          &lt;li&gt;비트 수의 30%를 계산하면 키의 근사 자릿수를 알 수 있다. 그렇다면 128의 30%는 약 38 이므로 128비트 암호화는 38자리 숫자 키를 이용한다.!&lt;/li&gt;
          &lt;li&gt;38자리 숫자는 매우 큰 수이고 현존하는 어떤 컴퓨터도 이 모든 가능성을 시도하는 데 수십억 년이 걸리므로 38자리 공유 비밀은 매우 안전하다고 할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_%EC%95%94%ED%98%B8&quot;&gt;블록 암호(Block cipher)&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;덧셈은 통계적으로 분석 가능한 결과를 낳고 이는 누군가가 암호화된 메시지 분석을 기반으로 키를 계산할 수도 있다.&lt;/li&gt;
          &lt;li&gt;변형된 덧셈트릭인 ‘블록암호’를 이용한다.&lt;/li&gt;
          &lt;li&gt;긴 메시지를 통상 10~15자로 이뤄진 고정된 크기의 작은 ‘블록’으로 쪼갠다.&lt;/li&gt;
          &lt;li&gt;그냥 메시지를 한 블록과 키를 더하는 대신 각 블록을 덧셈과 유사하지만 메시지와 키를 더 공격적으로 섞는 고정된 규칙에 따라 수 차례 변형한다.&lt;/li&gt;
          &lt;li&gt;오늘날의 블록 암호는 주로 10차례 혹은 그 이상 작업을 한다.&lt;/li&gt;
          &lt;li&gt;키를 아는 사람은 모든 계산을 역으로 구동해 해독된 원래 메시지를 얻을 수 잇다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B8%89_%EC%95%94%ED%98%B8%ED%99%94_%ED%91%9C%EC%A4%80&quot;&gt;AES(Advanced Encryption Standard)&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;다양한 설정으로 이용 할 수 있지만 일반적으로 16자짜리 블록을 128비트 키와 함께 이용해 10차례의 혼합 계산을 하는 방식으로 사용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공유 비밀을 공개적으로 설정하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;페인트 혼합 트릭(디피-헬만 키 교환)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%9C%AB%ED%95%84%EB%93%9C_%EB%94%94%ED%94%BC&quot;&gt;휫필드 디피&lt;/a&gt;와 마틴 헬만이 1976년에 발표하였다.&lt;/li&gt;
          &lt;li&gt;책에는 그림 예시와 설명을 통해 이방식을 설명하고 있다.&lt;/li&gt;
          &lt;li&gt;암호 키를 교환하는 하나의 방법으로, 두 사람이 암호화되지 않은 통신망을 통해 공통의 비밀키를 공유 할 수 있도록 한다.&lt;/li&gt;
          &lt;li&gt;이 방식은 기초적인 암호학적 통신 방법을 수립하였고, 이후 1977년 공개 키 암호 방식인 &lt;a href=&quot;https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8&quot;&gt;RSA&lt;/a&gt; 암호가 제안됨.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;숫자로 하는 페인트 혼합 트릭&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;컴퓨터는 혼합 계산으로 이산 누승법(discrete exponentiation) 과 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%82%B0_%EB%A1%9C%EA%B7%B8&quot;&gt;이산 로그(discrete logarithm)&lt;/a&gt;를 사용한다.&lt;/li&gt;
          &lt;li&gt;컴퓨터는 이산로그를 효율적으로 계산할 방법이 없다! (이점을 이용하면 일방향 암호화가 된다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;공개 키 암호화의 실체&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;RSA와 디피-헬만을 비롯한 공개 키 암호 시스템은 단순히 기발한 알고리즘 수준을 넘어선다. 이는 기업과 개인에게 동일하게 매우 중요한 상업 기술과 인터넷 표준으로 발전했다. 우리가 대부분은 공개 키 암호화 없이 안전하게 완료될 수 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-5---오류-정정-코드-데이터-오류를-스스로-찾아-고치는-마법&quot;&gt;Chapter 5 - [오류 정정 코드: 데이터 오류를 스스로 찾아 고치는 마법]&lt;/h3&gt;

&lt;p&gt;오류 정정 코드란 컴퓨터 데이터에서 오류를 검출해 정정하는 마법 같은 알고리즘이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;오류 검출과 정정의 필요성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터는 세 가지 근본적 작업을 수행한다. 가장 중요한 일은 &lt;strong&gt;계산수행&lt;/strong&gt;이다. 그러나 컴퓨터가 수행하는 다른 두 가지 매우 중요한 일이 없다면 답을 계산하는 능력조차 거의 무용지물이 될 것이다. 이는 데이터 &lt;strong&gt;저장&lt;/strong&gt; 과 &lt;strong&gt;전송&lt;/strong&gt; 이다.&lt;/li&gt;
      &lt;li&gt;데이터 전송과 저장과 관련된 큰 난관이 있다. 데이터는 정확해야 한다는 점이다. 많은 사소한 실수 하나조차 데이터를 무용지물로 만들 수 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;반복 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;같은 정보를 반복적으로 전송하여 가장 많이 전송된 값을 올바른 데이터라 판단하는 방법.&lt;/li&gt;
      &lt;li&gt;안타깝게도 오늘날의 컴퓨터 시스템에 별로 알맞지 않다. 데이터의 크기가 커졌기때문!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;리던던시 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;신뢰도를 향상시키기 위한 잉여 정보를 보낸다. 이를 리던던시(redundancy)라고 한다.&lt;/li&gt;
      &lt;li&gt;반복 트릭보다 더욱 선호한다. (상대적 비용(overhead)이 더 적다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;체크섬 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오류 정정을 하지않고 검출하는데만 집중하는 방법!&lt;/li&gt;
      &lt;li&gt;오류의 여부에 따라 재전송을 요청하도록 하는 방식이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;핀포인트 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;2차원 패리티(two-dimensional parity)라고 컴퓨터과학에서는 부른다.&lt;/li&gt;
      &lt;li&gt;패리티란 컴퓨터가 통상 쓰는 이진수로 작동하는 단순 체크섬을 뜻한다. 그리고 메세지를 이차원 격자(grid)에 배열하기에 이차원 패리티라고 부른다.&lt;/li&gt;
      &lt;li&gt;실제 컴퓨터에 이용했지만 이는 그 어떤 리던던시 트릭보다 비효율적이다. 하지만 시각화가 쉽고, 오늘날 컴퓨터 시스템에서 흔히 쓰는 코드 이면의 복잡한 수학을 요하지 않고도 오류를 찾고 정정하는 방법의 묘미를 전달하기에 적합하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실제 오류 정정과 검출&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;일반적으로 체크섬은 오류 정정보다 오류 검출에 널리 사용된다.
        &lt;ul&gt;
          &lt;li&gt;이더넷은 오늘날 지구에 있는 거의 모든 컴퓨터가 쓰는 네트워킹 프로토콜로서, CRC-32란 체크섬을 이용해 오류를 검출한다.&lt;/li&gt;
          &lt;li&gt;가장 유명한 인터넷 프로콜인 TCP도 보내는 데이터의 각 청크 또는 패킷에 체크섬을 이용한다. 체크섬이 부정확한 패킷은 폐기된다. tcp는 필요한 경우 이를 나중에 자동으로 재전송 하도록 설계됐기 때문이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인터넷 상에 배포되는 소프트웨어 패키지는 대개 검사 합계를 이용해 검증된다.
        &lt;ul&gt;
          &lt;li&gt;자주 쓰는 체크섬은 MD5와 SHA-1 이다.&lt;/li&gt;
          &lt;li&gt;둘다 암호학적 해시 함수로 고안돼 무작위 통신 오류뿐 아니라 소프트웨어의 악성 변형으로부터 보호 기능을 제공한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-6---패턴-인식과-인공지능-사람처럼-학습하고-생각하는-컴퓨터&quot;&gt;Chapter 6 - [패턴 인식과 인공지능: 사람처럼 학습하고 생각하는 컴퓨터]&lt;/h3&gt;

&lt;p&gt;인간의 타고난 이점을 활용하는 분야 -&amp;gt; &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%84%B4_%EC%9D%B8%EC%8B%9D&quot;&gt;패턴 인식(pattern recognition)&lt;/a&gt;
 인접이웃 분류자(nearest-neighbor classifier),&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B2%B0%EC%A0%95_%ED%8A%B8%EB%A6%AC&quot;&gt;의사 결정나무(decision tree)&lt;/a&gt;,&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%EA%B3%B5%EC%8B%A0%EA%B2%BD%EB%A7%9D&quot;&gt;인공 신경망(artificial neural network)&lt;/a&gt;에 대해서 알아본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;인접이웃 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;가장 단순한 형태의 인접이웃 트릭은 문자 그대로의 작업을 한다. 가장 근접한 이웃을 찾아 이 최근접 이웃의 클래스를 예측값으로 이용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스무고개트릭: 의사결정나무&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;스무고개와 같은 방식으로 동작한다.&lt;/li&gt;
      &lt;li&gt;분류자의 학습 단계는 복잡할 수 있지만 이는 완전히 자동이고 사람은 이를 단 한 번만 하면 된다. 그러면 우리가 필요로 하는 의사 결정나무를 갖게 되고 분류 단계는 놀랍도록 간단하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인공 신경망&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;뇌의 아주 작은 부분을 매우 단순하게 작동하도록 재현한 컴퓨터 모델이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패턴인식 :과거, 현재, 미래&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;패턴인식은 인공지능의 하위 분야다.&lt;/li&gt;
      &lt;li&gt;패턴인식은 소리, 사진, 영상 같은 데이터를 다루는 반면, 인공지능은 체스, 로봇 등 다양한 과제를 다룬다.&lt;/li&gt;
      &lt;li&gt;인공지능과 패턴 인식은 서서히 범위를 확장하고 있으며 성능을 향상시키고있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-7---데이터-압축-책-한-권을-종이-한-장에-담기&quot;&gt;Chapter 7 - [데이터 압축: 책 한 권을 종이 한 장에 담기]&lt;/h3&gt;

&lt;p&gt;압축은 컴퓨터시스템의 보이지 않는 곳에서 꽤 자주 이용된다. 예를 들어 인터넷을 거쳐 전송되는 많은 메시지는 사용자조차 모르는 사이에 압축되고 거의 모든 소프트웨어는 압축된 형태로 다운로드된다. 가장 보편적인 ZIP 파일 포맷은 이 장에서 설명할 기발한 압축 알고리즘을 이용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;무손실 압축: 최고의 공짜 점심&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;런-렝스 인코딩(run-length encoding)
        &lt;ul&gt;
          &lt;li&gt;특정 길이를 가진 반복의 런을 인코딩 하는 방법&lt;/li&gt;
          &lt;li&gt;ex) aaaabcbcbcaaaff -&amp;gt; 4a, 10bc,3a, 2fa1629715A&lt;/li&gt;
          &lt;li&gt;안타깝게도 이 인코딩법은 매우 특정한 유형의 데이터에만 유용하다.&lt;/li&gt;
          &lt;li&gt;실제로 이를 사용하기도 하지만 주로 다른 압축 알고리즘과 함께 쓴다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%97%88%ED%94%84%EB%A7%8C_%EB%B6%80%ED%98%B8%ED%99%94&quot;&gt;허프만 코딩&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;허프만 코딩과 함께 결합하여 팩스 기계에 사용한다. 팩스기계는 검색은이나 흰색의 수많은 점이기 때문에 가능하다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전과 같음 트릭(same-as-earlier trick)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이전에 나왔던 문자를 반복해서 말하지 않고 특정지점으로 돌아가서 복사하라는 식으로 하여 압축하는 방식.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;더 짧은 심벌 트릭(shorter-symbol trick)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;심볼 테이블을 작성하여 압축하는 방식.&lt;/li&gt;
      &lt;li&gt;짧은 내용을 압축할때는 효율이 적은거 같지만 사이즈가 커질수록 효율이 엄청나다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;요약: 공짜 점심은 어디서 올까?&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터의 전형적인 ZIP 압축 파일 제작 배후에 있는 모둔 중요한 개념
        &lt;ul&gt;
          &lt;li&gt;
            &lt;ol&gt;
              &lt;li&gt;압축되지 않은 원본 파일을 ‘전과 같음 트릭’ 을 이용해 변형해서 파일에 있는 반복 데이터 대부분을 돌아가서 데이터를 작성한다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;ol&gt;
              &lt;li&gt;변형된 파일에서 어떤 심벌이 자주 등장하는지 검토한다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;ol&gt;
              &lt;li&gt;2.에서 숫자 코드는 직접 번해해 다시 파일은 변형한다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;ol&gt;
              &lt;li&gt;2단계에서 계산된 숫자 코드 테이블도 ZIP파일에 저장한다. (나중에 풀기위함)&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;압축되지 않은 파일이 다르면 숫자 코드 테이블도 달라진다.&lt;/li&gt;
      &lt;li&gt;ZIP파일의 숫자 코드 테이블은 각각 다르다는 것 알 수 있다. (2단계로 인해서)&lt;/li&gt;
      &lt;li&gt;이 모든 과정은 효율적이고 자동적으로 이뤄지고 많은 유형의 파일에서 훌륭한 압축을 달성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;손실 압축: 공짜 점심은 아니지만 매우 좋은 거래&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이미지나 오디오 데이터는 손실 압축을 한다. (사람은 컴퓨터보다 덜 민감하기 때문에 가능)&lt;/li&gt;
      &lt;li&gt;생략 트릭
        &lt;ul&gt;
          &lt;li&gt;단순 생략
            &lt;ul&gt;
              &lt;li&gt;짝수번째 행과 열을 생략하여 데이터를 변형 (1/4로 줄일 수 있다)&lt;/li&gt;
              &lt;li&gt;픽셀의 일부 행과 열을 삭제 했기 때문에 사라진 픽셀을 추측해서 압축을 해제해야한다. (감안할 점)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;JPEG
            &lt;ul&gt;
              &lt;li&gt;지나치게 전문전인 압축법이라 간단히 설명할 수 없다.&lt;/li&gt;
              &lt;li&gt;기본적인 발상은 간단하다. 전체 이미지를 8x8픽셀 크기의 작은 정사각형으로 나눈다.&lt;/li&gt;
              &lt;li&gt;각 정 사각형을 개별적으로 압축한다. 칼라일경우 세배가 된다 (r,g,b)&lt;/li&gt;
              &lt;li&gt;정사각형이 약간의 차이만 있고 거의 동일한 색이라면 컴퓨터는 하나의 숫자로 대체할 수 있고, 압축을 해제했을 때 매우 작은 오류만이 드러나는 괜찮은 압축 결과를 낳는다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-8---데이터베이스-일관성을-향한-여정&quot;&gt;Chapter 8 - [데이터베이스: 일관성을 향한 여정]&lt;/h3&gt;

&lt;p&gt;거의 모든 온라인 거래는 1970년대이래 개발된 정교한 데이터베이스 기법을 이용해 처리된다. 
데이터 베이스는 두 가지 사안을 중요시 한다. &lt;strong&gt;효율성&lt;/strong&gt; 그리고 &lt;strong&gt;신뢰성&lt;/strong&gt;
이 장에서는 데이터베이스 이면의 근본적 알고리즘 세 가지를 다루겠다. 이는 미리 쓰기 로그(write-ahead logging), 2단계 커밋(2-phase commit), 관계형 데이터베이스(relational database) 이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션과 할 일 목록 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98&quot;&gt;트랜잭션(transaction)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;데이터 불일치, 충돌들을 피하고자 만들었음.&lt;/li&gt;
      &lt;li&gt;일관성 유지를 위해 트랜잭션 ‘복귀(rollback)’ 이란 개념도 존재한다.&lt;/li&gt;
      &lt;li&gt;충돌이란, 컴퓨터의 기능을 멈춰 데이터 손실을 야기할 수 있는 모든 사고를 아우른다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;할 일 목록 트릭&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;모든 사람이 체계적이지는 않다. 하지만 체계적인지 여부와 상관없이 매우 체계적인 사람이 가진 훌륜한 무기 중 하나는 ‘할 일’ 목록이다.&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;컴퓨터과학자들도 유사한 개념으로 &lt;strong&gt;미리 쓰기 로그&lt;/strong&gt; 란 용어를 사용한다.&lt;/li&gt;
          &lt;li&gt;기본 개념은 데이터베이스가 수행하려는 동작의 로그를 유지하는것이다. (하드 드라이브 등에 저장)&lt;/li&gt;
          &lt;li&gt;로그에 있는 정보는 충돌과 재시작 후에도 살아남게 된다. 모든 트랜잭션이 성공적으로 완료되면 할 일 목록을 삭제해 디스크 공간도 줄인다.&lt;/li&gt;
          &lt;li&gt;한 트랜잭션은 몇 번 수행 되더라도 상관없이 같은 효과를 내도록 고안되었다. 전문용어로 멱등(idempotent) 라고 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;크고 작은 원자성&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;트랜 잭션을 이해하는 또 다른 방법이있다. 데이터베이스 사용자의 관점에서 모든 트랜잭션은 원자성(atomicity)을 띤다.&lt;/li&gt;
          &lt;li&gt;할 일 목록 트릭은 원자적 트랜잭션을 제공해 일관성을 보장한다.&lt;/li&gt;
          &lt;li&gt;할 일 목록은 잠금(locking) 기법과 결합할 때 수천 개의 요청이 들어와도 일관성을 유지할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;할 일 목록 트릭은 데이터 오염을 사전에 차단하지만 데이터 손실을 제거하진 못한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중복 데이터베이스를 위한 준비 후 커밋 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;중복 데이터 베이스&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;하드웨어 이상으로 인한 영구적 데이터 손실은 할 일 목록 트릭으로는 도움이 되지 않는다.&lt;/li&gt;
          &lt;li&gt;두개 이상의 데이터베이스 사본 유지가 명백한 해결책이다.&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;백업(back up) 유지라는 친숙한 개념과는 조금 다르게 동작한다.&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;백업은 특정 시점 데이터의 스냅샷이다.&lt;/li&gt;
              &lt;li&gt;항상 최신 상태를 유지하진 않는다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;백업과 다르게 중복 데이터 베이스는 모든 사본을 늘 동기화한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트랙잰션 복귀&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;트랜잭션은 데이터베이스의 일관성을 보장하기 위해 반드시 수반되어야 하는 데이터베이스에 대한 일련의 처리 동작이다.&lt;/li&gt;
          &lt;li&gt;어떤 이유에서 트랙잭션을 완료 할 수 없을때도 있다. (디스크 공간부족 등)&lt;/li&gt;
          &lt;li&gt;대표적인 트랜잭션을 완료 할 수 없는 상황은 잠금(lock)상태이다. (교착상태)&lt;/li&gt;
          &lt;li&gt;교착상태 검사를 주기적으로 실행하여 트랜잭션 중 하나가 취소돼 나머지 트랜잭션을 진행 할 수 있도록 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;준비 후 커밋&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;2단계 커밋 프로토콜
            &lt;ul&gt;
              &lt;li&gt;1단계: 준비 단계.&lt;/li&gt;
              &lt;li&gt;2단계: 결정 또는 중단 단계.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;복제 본들이 트랜잭션을 완료할 수 있는지 없는지 여부를 보고 수행을 하도록 하는 것.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;관계형 데이터베이스와 가상 테이블 트릭&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오늘날 데이터베이스 테크놀로지의 진짜 힘은 복수의 테이블을 가진 데이터베이스에서 촉발됐다.&lt;/li&gt;
      &lt;li&gt;복수 테이블 접근의 이점은 저장해야 하는 정보의 양이 줄어든는 점이다.&lt;/li&gt;
      &lt;li&gt;테이블을 정확히 설계한다면 데이터베이스에 쉽게 변화를 줄 수 있다는 점이다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;키&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;테이블에 있는 상세 정보를 ‘찾아보는’ 데 이용하는 열을 데이터베이스 용어로 키(key)라고 한다.&lt;/li&gt;
          &lt;li&gt;사람이 사전에서 단어를 찾는 방식과 유사하다.&lt;/li&gt;
          &lt;li&gt;빠르게 키를 찾고자 사전에 계산된 묶음의 집합을 컴퓨터과학에서는 B-트리(B-tree)라 한다. 이는 오늘날 데이터베이스를 뒷받침하는 또 하나의 중요하고 기발한 개념이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;가상 테이블 트릭&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;기본 아이디어는 데이터베이스의 모든 정보는 고정된 테이블에 저장되지만 데이터베이스는 필요할 때마다 완전히 새로운 테이블을 일시적으로 생성할 수 있는데, 이 처럼 일시적으로 추가하는 테이블은 어디에도 실제로 저장되지 않는 &lt;strong&gt;가상 테이블&lt;/strong&gt; 을 만드는 것이다.&lt;/li&gt;
          &lt;li&gt;join(조인)이라는 명령을 이용하여 가상 테이블을 생성한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;관계형 데이터베이스&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;상호 연결된 테이블에 있는 모든 데이터를 저장하는 데이터베이스를 관계형 데이터베이스라 부른다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-9---디지털-서명-진짜-누가-이-소프트웨어를-작성했을까&quot;&gt;Chapter 9 - [디지털 서명: 진짜 누가 이 소프트웨어를 작성했을까?]&lt;/h3&gt;
&lt;p&gt;디지털(digital)이라는 단어를 문자 그대로 해석하면 ‘숫자 열로 구성된’ 이란 뜻이다. 서명(signature)의 핵심은 서명한 사람 이외의 사람이 읽을 순 있지만 복사(위조) 할 수 없다는 데 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;디지털 서명의 실제 목적은?&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;종이 서명에서는 여러분이 상대방에게 보낼 내용에 서명을 하지만, 디지털 서명에서는 상대방이 여러분에게 내용을 보내기 전에 서명한다.&lt;/li&gt;
      &lt;li&gt;사람들이 잘 인식하지 못하는 이유는 컴퓨터가 디지털 서명을 자동으로 확인하기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RSA의 보안&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 디지털 서명 체계의 보안 문제는 ‘적이 내 서명을 위조할 수 있는가?’ 라는 질문으로 압축된다.&lt;/li&gt;
      &lt;li&gt;RSA 체계는 엄청나게 큰 시계 크기를 쓴다는 데 있다. (수천자리에 이름) 현존하는 컴퓨터 중 가장 빠른 컴퓨터조차 모든 가능한 자물쇠 값을 시도해 보는 데 수조 년이 걸린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실제 디지털 서명&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;일부 컴퓨터에 정통한 사용자는 이메일 메시지 같은 곳에 서명을 하지만 대부분은 다운로드한 내용을 검증할 때 디지털 서명을 주로 사용한다.&lt;/li&gt;
      &lt;li&gt;서명은 다른 메세지로 전환될 수 없으므로, 이를 그냥 복사한다고 해서 위조할 수 있는것은 아니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-10---계산-가능성과-결정-불가능성-컴퓨터로-모든-문제를-해결할-수-있을까&quot;&gt;Chapter 10 - [계산 가능성과 결정 불가능성: 컴퓨터로 모든 문제를 해결할 수 있을까?]&lt;/h3&gt;
&lt;p&gt;미래에 아무리 많은 기발한 알고리즘이 개발되더라도 ‘컴퓨터로 해결할 수 없는’ 문제는 늘 존재 할 것이다.
이 장은 간단한 정리로 마무리한다. 책의 예시를 다 적을순 없으므로…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;버그, 충돌, 소프트웨어의 신뢰성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;어떠한 소프트웨어 검사 도구라도 ‘모든’ 프로그램에 잠재해 있는 충돌을 ‘모두’ 검출하는 일은 불가능하다는 것을 증명할 수 있다.&lt;/li&gt;
      &lt;li&gt;모든 충돌을 검출하는 프로그램은 존재할 수 없다는 사실을 귀류법으로 증명할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Book" /><category term="미래를 바꾼 아홉가지 알고리즘" /><category term="책정리" /><category term="독서" /><summary type="html">우연히 발견한 책이지만, 나름 재밌게 읽어서 정리함.</summary></entry><entry><title type="html">독서: 소프트웨어 장인정신</title><link href="http://0.0.0.0/etc/2019/12/21/Book-The-Software-Craftsman.html" rel="alternate" type="text/html" title="독서: 소프트웨어 장인정신 " /><published>2019-12-21T00:00:00+09:00</published><updated>2019-12-21T00:00:00+09:00</updated><id>http://0.0.0.0/etc/2019/12/21/Book-The-Software-Craftsman</id><content type="html" xml:base="http://0.0.0.0/etc/2019/12/21/Book-The-Software-Craftsman.html">&lt;p&gt;소프트웨어 개발자로써 읽어야할 책이라길래 읽고 가볍게 정리해보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/post_img/software_crafts_man.jpg&quot; alt=&quot;소프트웨어 장인&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;-소프트웨어-장인-&quot;&gt;&lt;a href=&quot;https://www.yes24.com/24/Goods/20461940?Acode=101&quot;&gt; 소프트웨어 장인 &lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;part1-이념과-태도&quot;&gt;PART1 &lt;strong&gt;이념과 태도&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;chapter-1---21세기의-소프트웨어-개발&quot;&gt;Chapter 1 - [21세기의 소프트웨어 개발]&lt;/h3&gt;
&lt;p&gt;코딩을 잘 하거나 특정 언어나 프레임워크에 매우 익숙하다고해서 고참 개발자가 되는 것은 아니라고한다. 
이제 개발자들은 아래와 같은 여러가지를 할 수 있어야한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;고객과 대화하기&lt;/li&gt;
  &lt;li&gt;테스트/배포 자동화하기&lt;/li&gt;
  &lt;li&gt;전체 비지니스에 영향을 미칠 기술 선정하기&lt;/li&gt;
  &lt;li&gt;지리적으로 분산된 팀들과 협업하기&lt;/li&gt;
  &lt;li&gt;고객을 도와 필요한 작업을 정의하기&lt;/li&gt;
  &lt;li&gt;우선순위 정하기&lt;/li&gt;
  &lt;li&gt;진척 상황 보고하기&lt;/li&gt;
  &lt;li&gt;변경사항과 기대일정 관리하기&lt;/li&gt;
  &lt;li&gt;잠재 고객 및 파트너에게 제품 소개하기&lt;/li&gt;
  &lt;li&gt;사전 영업 활동 지원하기&lt;/li&gt;
  &lt;li&gt;개발 일정과 비용 산출하기&lt;/li&gt;
  &lt;li&gt;채용 면접하기&lt;/li&gt;
  &lt;li&gt;아키텍처 설계하기&lt;/li&gt;
  &lt;li&gt;비기능적 요구사항과 계약조건 검토하기&lt;/li&gt;
  &lt;li&gt;사업 목표 이해하기&lt;/li&gt;
  &lt;li&gt;주어진 여건에서 최적의 결정하기&lt;/li&gt;
  &lt;li&gt;새로운 기술 주시하기&lt;/li&gt;
  &lt;li&gt;더 나은 업무 방식 찾기&lt;/li&gt;
  &lt;li&gt;고객에게 가치 있는 상품이 전달되고 있는지 고민하기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-2---애자일&quot;&gt;Chapter 2 - [&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C&quot;&gt;애자일&lt;/a&gt;]&lt;/h3&gt;
&lt;p&gt;애자일은 어떤 단일 개념이 아니다. 서로 다른 여러 맥락에 따른 방법론과 테크닉의 조합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;절차적인 관점에서의 애자일 원칙
    &lt;ul&gt;
      &lt;li&gt;팀에 정말로 중요한 것, 비즈니스에 가치가 있는 것에 집중한다. 이러한 방법론들을 통해 팀이 올바른 결과물을 만들어 가는지, 즉 &lt;strong&gt;올바른 목표를 향해 진행 중&lt;/strong&gt;인지 확인할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기술적인 관점에서의 애자일 원칙
    &lt;ul&gt;
      &lt;li&gt;개발, 확장, 유지보수, 제품을 출시(또는 납품, 서비스 배포)하면서 겪는 어려움들에 대해 틀정한 기술적 관례나 기술 자체를 매우 구체적으로 가이드한다. (&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C&quot;&gt;TDD&lt;/a&gt;, 페어 프로그래밍, 지속적인 통합, 단순한 디자인 원칙 등)&lt;/li&gt;
      &lt;li&gt;즉 ** 목표한 것을 올바르게 실행하고 있는지**에 대해 안심할 수 있게 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;애자일 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A7%A4%EB%8B%88%ED%8E%98%EC%8A%A4%ED%86%A0&quot;&gt;메니페스토&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;절차와 도구보다는 &lt;strong&gt;개성과 화합을&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;방대한 문서 작업보다는 &lt;strong&gt;동작하는 소프트웨어를&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;계약 조건에 대한 협상보다는 &lt;strong&gt;고객과의 협력을&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;계획을 따르는 것을 넘어서서 &lt;strong&gt;변화에 대처하는 것을&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;더 가치있게 여긴다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-3---소프트웨어-장인정신&quot;&gt;Chapter 3 - [소프트웨어 장인정신]&lt;/h3&gt;
&lt;p&gt;소프트웨어 장인정신은 소프트웨어 개발의 프로페셔널리즘에 대한 것이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;소프트웨어 장인을 열만하는 우리는, 스스로의 기술을 연마하고, 다른 사람들이 기술을 배울 수 있도록 도움으로써 프로페셔널 소프트웨어 개발의 수준을 높인다. 이러한 일을 하는 과정에서 우리는 다음과 같은 가치들을 추구한다.
    &lt;ul&gt;
      &lt;li&gt;동작하는 소프트웨어뿐만 아니라, &lt;strong&gt;정교하고 솜씨 있게 만들어진 작품을,&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;변화에 대응하는 것뿐만 아니라, &lt;strong&gt;계속해서 가치를 더하는 것을,&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;개별적으로 협력하는 것뿐만 아니라, &lt;strong&gt;프로페셔널 커뮤니티를 조성하는것을,&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;고객과 협업하는 것뿐만 아니라, &lt;strong&gt;생산적인 동반자 관계를,&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 왼쪽의 항목들을 추구하는 과정에서, 오른쪽 항목들이 꼭 필요함을 의미한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;소프트웨어 장인은 고객과 고용자•피고용자 관계가 아닌 생산적인 동반자 관계를 기대한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-4---소프트웨어-장인의-태도&quot;&gt;Chapter 4 - [소프트웨어 장인의 태도]&lt;/h3&gt;
&lt;p&gt;오래 전에 작성했던 코드를 지금에 와서도 고칠 부분이 없어 보인다면, 그것은 그동안 배운 것이 없다는 뜻이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;끊임 없는 자기계발&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;독서, 많은 독서
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;특정 기술에 대한 서적&lt;/strong&gt;: 업무를 위해 어떤 프레임워크나 프로그래밍 언어 또는 특정 소프트웨어의 이용 방법을 급하게 알아야 할 때 꼭 필요하다. 당장의 업무에는 유용하지만 그 가치가 오래가지는 않는다. (java, Hibernate, Node.js, Clojure 등)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;특정 개념에 대한 서적&lt;/strong&gt;: 커리어를 진전시킬 때 필요한 기초를 쌓을 수 있는책이다. 새로운 개념이나 패러다임 또는 실행 관례들을 소개한다. 장장 활용하기는 어렵고, 제대로 이해하고 습득하는 데 긴 시간이 필요할 때도 있다. (TDD, 도메인 기반 개발, 객체 지향 설계, NoSQL 데이터베이스 모델 등)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;행동양식에 대한 서적&lt;/strong&gt;: 효율적으로 팀에서 일할 수 있게 안내하거나, 일반적인 상황에서 더 나은 프로페셔널이 될 수 있도록 조언한다. 팀 동료나 고객 등 사람들을 어떻게 대하고 일정을 어떤 방식으로 관리하면 되는지 설명한다. (애자일 방법론, 소프트웨어 장인정신, 린 소프트웨어 개발, 심리학, 경영 등)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;혁명적 서적(또는 고전)&lt;/strong&gt;: 일하는 방식이나 개인의 가치관을 바꾸는 책이다. 이전과는 전혀 다른 가치나 원칙들을 제시해 다수에게 무시되거나 배척되지만 결국에는 주류 사상으로 자리매김한다. 소프트웨어 개발자라면 이미 읽어 보았음ㅇ직한 것들로 일상적인 업무 중 대화에서도 그 내용이 흔하게 언급된다. (실용주의 프로그래머, 디자인 패턴, 테스트 주도 개발 등)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;블로그
        &lt;ul&gt;
          &lt;li&gt;블로그를 이용하면 항상 최신 정보를 습득할 수 있다.&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;실제 경험, 개인적인 발견, 의견, 성공담, 실패담들이 짧게 담겨 있기 때문에 소프트웨어 장인정신이나 애자일 모델에 태생적으로 궁합이 잘 맞다.&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;사전에 충분한 지식이 없는 사람에게는 블로그가 독이 될 수도 있다. 많은 연구 없이 깊이가 없는 글이 올라오는 블로그도 꽤 많기 때문이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;기술 웹사이트
        &lt;ul&gt;
          &lt;li&gt;온라인 기술 잡지와 같은 많은 웹사이트들에서 새로운 트렌드나 기술들을 소개하고 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-5---영웅-선의-그리고-프로페셔널리즘&quot;&gt;Chapter 5 - [영웅, 선의 그리고 프로페셔널리즘]&lt;/h3&gt;

&lt;p&gt;프로답게 행동하고 고객을 만족시킨다는 것이 고객의 요구사항을 모두 받아들이라는 뜻은 아니다. 고객이 무엇을 가장 필요로 하는지, 그것을 얻기 위한 최선의 방법을 도우며 조언하는 것이 우리의 일이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;의도한 대로 동작할 수 없거나, 실행 불가능한 무리한 일정에 대해서 “아니오” 라고 답하는 것은 우리의 의무다.&lt;/li&gt;
  &lt;li&gt;고객은 문제를 들고 프로페셔널을 찾아간다. 프로페셔널들이 그들의 경험과 지식을 활용해 그 문제를 다룰 방법들에 어떤 것들이 있고 각각의 장단점은 무엇인지를 알려주길 기대한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-6---동작하는-소프트웨어&quot;&gt;Chapter 6 - [동작하는 소프트웨어]&lt;/h3&gt;

&lt;p&gt;전통적인 관리자들과 비즈니스 컨설턴트들이 절차와 문서의 중요성을 아무리 강조하고 싶어하더라도 소프트웨어 프로젝트에는 소스 코드 그 자체만큼 중요한 것은 없다. 나머지는 부차적이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래밍은 집을 짓는다기보다는 정원을 돌보는 것에 더 가깝다 (‘&lt;a href=&quot;https://www.yes24.com/24/Goods/12501565?Acode=101&quot;&gt;실용주의 프로그래머&lt;/a&gt;’ 인용)
    &lt;ul&gt;
      &lt;li&gt;코드는 정원처럼 지속적인 유지보수가 필요하다.&lt;/li&gt;
      &lt;li&gt;시간이 있어 개발자 스스로 자동화 테스트를 구현하지 않으려는 경우도있다. 이러한 개발자는 테스트하지 않아서 발생할 수 있는 파급 효과를 무시한 채 스스로 “나는 테스트 코드를 작성할 시간이 없다” 라고 단정한다. 자신의 작업 시간만 생각하고 전체 프로젝트에 관계된 다른 사람들이 시스템을 테스트하고 디버깅하느라 얼마나 많은 시간을 소모해야 하는지는 생각하지 않는 사람이다. 항상 프로젝트에 다른 사람들도 있다는 사실을 인식하고 전체 프로젝트에 미치는 영향을 감안하여 책임있게 행동해야 한다.&lt;/li&gt;
      &lt;li&gt;자신이 짠 코드는 어떻게 동작하는 지 잘 알고 있고 문제가 없을 터이니 테스트 코드를 따로 안 만들어도 된다고 주장하는 개발자는 대단히 자기 중심적이고 이기적인 사람이다. 소프트웨어 프로젝트는 팀워크다. 특정 개발자 한 사람을 위한 것이 아니다. 특정 개발자에게 쉽고 분명한 것이 팀내 다른 개발자에게는 난해하고 불분명할 수 있다. 시스템이 커짐에 따라 프로젝트에 관계된 모든 사람들이 개인의 작은 이기적 행동들 때문에 피해를 입게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-7---기술적-실행-관례&quot;&gt;Chapter 7 - [기술적 실행 관례]&lt;/h3&gt;

&lt;p&gt;개발자는 왜 테스트 주도 개발(TDD)이나 페어 프로그래밍 같은 익스트림 프로그래밍(XP)의 관례들에 관심을 가져야 할까 ?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자동화된 테스트
    &lt;ul&gt;
      &lt;li&gt;자동화된 테스트는 클릭 한번으로 전체 시스템을 단 몇 분만에 검증할 수 있게 해준다. 자동화된 테스트가 있으면 코드를 수정한 지 몇 분만에 안심하고 상용 릴리즈에 반영할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 먼저
    &lt;ul&gt;
      &lt;li&gt;테스트 코드를 먼저 작성하면 여러 가지 장점이 있다. 아이디어를 생각 해내는 데도 도움이 되고 한 번에 하나씩만 집중할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 주도 개발
    &lt;ul&gt;
      &lt;li&gt;테스트 주도 개발(TDD)은 테스트 코드를 먼저 작성한다는 것의 진화된 버전이다. 가장 흔한 오해가 TDD를 단위 테스트와 동일하게 생각하는 것이다.&lt;/li&gt;
      &lt;li&gt;TDD의 이름 자체에 ‘테스트’가 들어 있기는 있지만 사실 TDD는 설계에 대한 실행 관례다. 테스트가 코딩 방향을 주도하면 복잡한 코드를 작성하는것 자체가 어려워 진다.
        &lt;ul&gt;
          &lt;li&gt;정확히 요구사항만큼만 만족시키는, 즉 테스트로 규정된 부분만 작성하게 되기 때문이다.&lt;/li&gt;
          &lt;li&gt;코드가 복잡하고 방대하면 테스트 자체가 어렵기 때문이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-8---길고-긴-여정&quot;&gt;Chapter 8 - [길고 긴 여정]&lt;/h3&gt;

&lt;p&gt;우리는 정말 커리어를 제대로 도보고 있는가? 어디로 가고 있는지, 어디로 가고 싶은지 진정으로 알고 있는가? 우리의 일을 투자로 바라보아야 하는가? 그렇다면 그 투자에 대한 보상은 무엇이어야 할까?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;기회를 만들어 내기 위해 할 수 있는 몇 가지 활동들&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;익숙하고 편한 것에서 벗어나 새로운 것을 공부하고 기술적 지식을 확장한다. 예를 들어 새로운 프로그래밍 언어나 기술들을 배운다.&lt;/li&gt;
      &lt;li&gt;지역 커뮤니티에 정기적으로 출석하거나 행사에 참여한다.&lt;/li&gt;
      &lt;li&gt;다른 개발자, 비즈니스맨들과 교류한다.&lt;/li&gt;
      &lt;li&gt;새롭게 배운것, 지금 하고 있는 것들에 대해 블로깅한다.&lt;/li&gt;
      &lt;li&gt;오픈 소스 프로젝트에 참여한다.&lt;/li&gt;
      &lt;li&gt;프로젝트를 만들고 공개한다.&lt;/li&gt;
      &lt;li&gt;컨퍼런스에 참석한다.&lt;/li&gt;
      &lt;li&gt;컨퍼런스에서 연사로 나선다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;역량이 더 높아질수록, 스스로에게 기쁨을 주는 일을 찾기가 쉬워진다. 좋은 일감을 얻을 수 있는 위치에 도달하려면 커리어의 개발 과정 중에 많은 집중과 결단력이 필요하다. 성공적인 커리어는 공짜로 오지 않는다. 스스로 만들어 나가야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 회사 안에서의 커리어보다 개인으로서 우리 자신의 커리어가 항상 우선해야 한다. 물론 회사 안에서의 커리어가 개인의 커리어와 일치한다면 대단한 행운이지만 회사가 개인의 커리어를 통제하는 경우가 대부분이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;일을 신중히 선택하고 고객들을 만족시켜 나가면, 소프트웨어 장인으로서 매우 성공적이고 즐거운 커리어를 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;part2-완전한-전환&quot;&gt;PART2 &lt;strong&gt;완전한 전환&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;part2 부분은 인재채용 및 면접에 관한 내용이 주로 나오기 때문에, 간단한 정리만 한다. 자세한 내용은 책을 읽기!&lt;/p&gt;

&lt;h3 id=&quot;chapter-9---인재-채용&quot;&gt;Chapter 9 - [인재 채용]&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;미래의 성공 가능성을 높이기 위해서는 열정적인 개발자를 찾아야한다. 열정적인 개발자는 개방된 사고로 항상 무언가를 배우기를 원하기 때문이다. 그들은 스스로 동기가 부여되어 혁신하고 기술 변화를 이끈다. 그들은 누가 무엇을 하라고 할 때까지 기다리지 않는다. 무언가를 시킬 때까지 그저 가만 있는 사람들은 회사를 정체 상태로 이끌어 피해야 할 사람들이다. 열정적인 개발자는 성장하기 위해 개인 시간을 기꺼이 투자한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;당장 오늘은 미숙하더라도 그리 길지 않은 시간이 지나면 훌륭한 프로페셔널이 될 가능성이 매우 높다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-10---소프트웨어-장인-면접하기&quot;&gt;Chapter 10 - [소프트웨어 장인 면접하기]&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;면접은 쌍방향이다.&lt;/strong&gt; 회사는 그들의 목적을 달성하는 데 도움을 줄 수 있는 개발자를 찾으려 하고, 개발자는 자신의 열망과 커리어 방향에 적합한 회사를 찾으려한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;개발자 채용 면접은 개발자가 보아야 한다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;좋은 개발자는 나쁜 개발자를 채용하지 않는다. 좋은 개발자는 그들 자신 보다도 더 훌륭한 개발자를 찾으려 노력한다. 좋은 개발자는 훌륭한 팀을 구성하는 것이 얼마나 중요한지 잘 알고 있다. 훌륭한 팀은 회사뿐만 아니라 개발자들 자신에게도 이익이 된다.&lt;/li&gt;
      &lt;li&gt;회사는 개발자 채용 면접을 할 때 반드시 개발자로 하여금 면접관 역할을 하도록 해야 한다. 지원자 입장에서도 개발자가 아닌 사람이 면접을 하고 있다면 다른 회사를 찾아보는 것이 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-11---잘못된-면접-방식&quot;&gt;Chapter 11 - [잘못된 면접 방식]&lt;/h3&gt;
&lt;p&gt;회사의 채용 절차를 하나하나 상세하게 뜯어보면 그 회사가 추구하는 가치와 문화를 엿볼 수 있다. 경험 많고 재능있는 개발자들은 자신이 일할 회사 또는 고객을 신중하게 가려서 선택한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;잘못된 변접 방식
    &lt;ul&gt;
      &lt;li&gt;똑똑한 척하는 면접관을 세운다.
        &lt;ul&gt;
          &lt;li&gt;면접관의 사사로운 즐거움을 위해 지원자를 힘든 상황으로 몰아붙이고, 자신의 직함, 권한, 지식같은 것들로 지원자를 압도하고 싶어 해서는 안 된다.&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;즉, 면접관이 거만하고 오만한 사람이 되어서는 안 된다.&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;수수께끼식 질문을 던진다.&lt;/li&gt;
      &lt;li&gt;답을 모르는 질문을 한다.&lt;/li&gt;
      &lt;li&gt;지원자를 바보로 만든다.&lt;/li&gt;
      &lt;li&gt;인터넷 접속을 막는다.
        &lt;ul&gt;
          &lt;li&gt;솔루션들을 탐색하고 더 나은 문제 대응 방법을 찾는 것은 소프트웨어 개발자로서 갖추어야 할 핵심적인 능력이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;종이에 코드를 작성하게 한다.&lt;/li&gt;
      &lt;li&gt;알고리즘 문제를 낸다.
        &lt;ul&gt;
          &lt;li&gt;시스템 개발에 필요한 상당수의 업무들이 알고리즘에 대한 깊은 이해를 필요로 하지 않는다.&lt;/li&gt;
          &lt;li&gt;물론 틀린 이야기는 아니지만 알고리즘 문제 대신 회사의 실제 프로젝트와 가까운 다른 연습문제를 통해서도 ‘문제 해결 능력’을 평가 할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;전화 면접을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요약
    &lt;ul&gt;
      &lt;li&gt;좋은 개발자를 찾기는 꽤 어렵고 오랜 시간이 걸린다. 두뇌 장난같은 수수께끼를 내는 등 지원자를 바로처럼 느끼게 하는 면접은 훌륭한 지원자가 당신과 함께 일하기 싫어하게 만드는 지름길이다. 코딩 면접을 할 때 인터넷 접속을 끊거나 종이나 화이트보드에 코드를 작성하게 하는 것 또한 의미도 없고 지원자의 화를 복돋우기 십상이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-12---낮은-사기의-대가&quot;&gt;Chapter 12 - [낮은 사기의 대가]&lt;/h3&gt;

&lt;p&gt;개발자들의 낮은 사기는 소프트웨어 프로젝트 실패의 주된 이유 중 하나다. 사기가 낮으면 회사 전체가 멈추기도 한다. 
이장에서는 개발자들의 사기가 프로젝트와 회사에 어떤 영향을 미치는지 설명 되어있고, 맥 빠진 팀에 다시 열정을 불어 넣으려 할 때 소프트웨어 장인이 어떤 도움을 줄 수 있는지도 알아본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 회사들이 문제를 안고 있다. 어떤 구성원이든지 간에, 회사가 좀더 나아졌으면 하는 항목들을 쉽게 떠올릴 수 있다. 그렇다면 왜 그렇게 되도록 만들려는 노력들을 하지 않는 것일까? 그 이유에 대한 몇가지는 아래와 같다.
    &lt;ul&gt;
      &lt;li&gt;자신에게 아무런 권한이 없다고 생각한다.&lt;/li&gt;
      &lt;li&gt;그런 일을 이끌어가야 할 당사자가 되고 싶지 않다.&lt;/li&gt;
      &lt;li&gt;그렇게 되기에는 복잡한 장애요인이 너무 많다.&lt;/li&gt;
      &lt;li&gt;뭔가 바뀌는 것이 가능하다고 믿지 않는다.&lt;/li&gt;
      &lt;li&gt;무엇이 더 나은 일인지 사람들의 동의를 받기 힘들다.&lt;/li&gt;
      &lt;li&gt;아무 상관 없다. 그냥 출퇴근만 하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요약
    &lt;ul&gt;
      &lt;li&gt;직원들의 사기가 낮으면 회사가 파괴되기 쉽다. 동기부여가 되지 않는 사람들은 혁신을 창조하고 적용할 에너지가 없다. 일을 제대로 하고 책임을 지는 데도 관심이 없다. 그 사람들이 원래 그랬던 것은 아니다. 상황이 그렇게 만들어간다. 사람들의 열정을 없애는 데 정말 능숙한 회사들도 있다. 다행인 것은 관리층으로부터의 진심 어린 지원이 있다면 점진적으로 ‘낮은 사기’ 에 빠져 있는 상황을 역전시킬 수 있다는 점이다.&lt;/li&gt;
      &lt;li&gt;개발자 들이 생각하는 커리어와 열정에 대해 공유해야 한다. 개발자에게 동기를 부여할 수 있는 최선의 사람은 바로 동료 개발자다. 실력있는 개발자, 본받고 싶고 영감을 일으키는 개발자, 바로 소프트웨어 장인이야 말로 최고의 동기 부여가 될 수 있다. 개발팀에 열정을 불어넣고 동기를 부여하고 싶다면 소프트웨어 장인 몇 명을 팀에 영입해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-13---배움의-문화&quot;&gt;Chapter 13 - [배움의 문화]&lt;/h3&gt;

&lt;p&gt;배움의 문화를 하기에 시간이나 장소가 없다는 것은 변명이 될 수 없다. 관리자로부터의 지원이 없더라도 개발자들 스스로 서로 배우고 공유하는 배움의 환경과 문화를 쉽게 만들 수 있다. 장소가 없다면 가까운 카페를 찾아가자. 시간이 없다면 점심 시간이나 업무 전 시간을 이용하자. 매일 할 수는 없다면 일주일에 한 번만 하자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;많은 회사들과 관리자들은 다르게 생각하고 있지만, 배움의 문화를 만드는 것은 쉽고 비용이 거의 안 드는 일이다. 열정적인 개발자들에게 좋은 환경을 제공하기만 하면 된다. 그러면 그들 스스로 무엇을 배우고 공유 할지 여러 가지 방법을 찾을 것이다.&lt;/li&gt;
  &lt;li&gt;회사에도 품질과 혁신을 가져다 줄 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-14---기술적-변화의-실행&quot;&gt;Chapter 14 - [기술적 변화의 실행]&lt;/h3&gt;

&lt;p&gt;개발팀에 기술적 변화를 도입하는 일은 참 어렵다. 사실 대단히 어렵다. 성공적으로 변화를 일으키려면 여러 종류의 사람들마다 어떻게 다르게 대응하고 어떻게 설득할지 알고 있어야 한다. 사람들은 바보가 아니다. 스스로가 믿고 있는 것들에 대해 서로 다른 이유와 서로 다른 의견을 가지고 있을 뿐이다. 그들의 의견은 과거의 경험을 바탕으로 하고 있거나, 당신이 모르는 정보를 알고 있거나, 자신감이 부족하거나 어쩌면 두려움때문일 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;일을 잘 해내려면 소통을 명확히 해야 한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;무엇보다도 개발자들과 신뢰를 쌓는 방법을 알고 있어야 한다. 신뢰야말로 변화를 이끌기 위한 핵심적인 요소다. 대화하는 상대방을 이해하고, 그 사람의 생각의 바탕에 어떤 이유들이 있는지 공감할 수 있어야 한다. 자신을 준비시키고 용감해지고, 주도하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-15---실용주의-장인정신&quot;&gt;Chapter 15 - [실용주의 장인정신]&lt;/h3&gt;

&lt;p&gt;실용주의가 없는 장인정신은 장인정신이 아니다. 장인이 가장 중요하게 초점을 맞추는 것은 고객의 만족이다. 품질은 물론이고 시간과 비용도 고객만족을 위한 구성요소다. 고객에게 가치를 전달할 수 없다면 잘 작성된 코드라고 할 수 없다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;고객이 소프트웨어 프로젝트를 통해 무엇을 성취하려 하는지 반드시 이해해야 한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;품질은 비싼 것이 아니다. 스킬 부족이 잘 작성된 코드를 비싼 것으로 만드는 원인이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시간이나 비용과 같은 대가가 따르지 않는다면 항상 높은 품질을 선택한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-16---소프트웨어-장인으로서의-커리어&quot;&gt;Chapter 16 - [소프트웨어 장인으로서의 커리어]&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;열정.&lt;/strong&gt; 이 단어 하나가 모든 것을 요약한다.
    &lt;ul&gt;
      &lt;li&gt;개발과 자신의 직무에 열정적이다.&lt;/li&gt;
      &lt;li&gt;문제를 단순한 방법으로 푸는 데 열정적이다.&lt;/li&gt;
      &lt;li&gt;배우고 가르치고 공유하는 데에 열정적이다.&lt;/li&gt;
      &lt;li&gt;소프트웨어 산업이 진화하도록 돕는 데도 열정적이다.&lt;/li&gt;
      &lt;li&gt;코드를 공유하고, 초보 개발자들을 멘토링하고, 블로그/책/동영상/대화 등을 통해 그들의 경험을 공유하는 데도 열심이다.&lt;/li&gt;
      &lt;li&gt;기술 커뮤니티 활동에도 열정적이다.&lt;/li&gt;
      &lt;li&gt;겸손하다.&lt;/li&gt;
      &lt;li&gt;항상 무언가를 배울 자세가 되어있고, 경험이 적은 개발자들을 돕기를 주저하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;소프트웨어 장인의 사명
    &lt;ul&gt;
      &lt;li&gt;더 나아지는 데 집중하고&lt;/li&gt;
      &lt;li&gt;계속해서 자신의 커리어에 투자하며, 배우고, 가르치고, 공유한다.&lt;/li&gt;
      &lt;li&gt;맡은 고객에게 항상 가치를 전달할 수 있도록 해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Book" /><category term="Software" /><category term="책정리" /><category term="소프트웨어 장인정신" /><category term="독서" /><summary type="html">소프트웨어 개발자로써 읽어야할 책이라길래 읽고 가볍게 정리해보았다.</summary></entry></feed>